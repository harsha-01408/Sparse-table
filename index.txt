Title: Static Range Maximum Query (Sparse Table Classic)

Title Background
This is a classic ST (Sparse Table) problem — Static interval maximum.

Please note that the maximum time limit is only 0.8s and the data strength is not low. You must ensure your per-query complexity is O(1). Using a higher time complexity algorithm may not pass.

If you believe your algorithm has the right complexity but you still get TLE, try using fast input. For example, in C++:

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
    return x * f;
}

(The function returns the first integer read in. Fast I/O is optional; it only helps speed up input.)

Problem Description
You are given a sequence of length N and M queries. For each query, find the maximum value in the specified interval.

Input Format
- The first line contains two integers N and M — the length of the sequence and the number of queries.
- The second line contains N integers A_i, representing the elements of the sequence.
- Each of the next M lines contains two integers L_i and R_i, indicating a query interval [L_i, R_i] (1-indexed, inclusive).

Output Format
Output M lines, one integer per line, where each line is the maximum value in the corresponding query interval.

Sample Input
8 8
9 3 1 7 5 6 0 8
1 6
1 5
2 7
2 6
1 8
4 8
3 7
1 8

Sample Output
9
9
7
7
9
8
7
9

Constraints
- 1 ≤ N ≤ 10^5
- 1 ≤ M ≤ 2 × 10^6
- 0 ≤ A_i ≤ 10^9
- 1 ≤ L_i ≤ R_i ≤ N

Notes / Tips
- This is a static RMQ (Range Maximum Query) with no updates. Preprocess in O(N log N) using a Sparse Table, answer each query in O(1).
- Due to large M and tight time limit, consider fast I/O (e.g., scanf/printf, ios::sync_with_stdio(false), or the provided read() function in C++).

xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Title: Balanced Lineup (USACO 2007 JAN) — Range Max–Min Query

Problem Description
Farmer John’s N cows (1 ≤ N ≤ 5×10^4) stand in a fixed order. He considers Q (1 ≤ Q ≤ 1.8×10^5) possible contiguous groups of cows. For each query range [A, B] (1-indexed, inclusive), report the difference between the tallest and the shortest cow within that range.

Input Format
- The first line contains two integers N and Q.
- The next N lines each contain an integer H_i — the height of the i-th cow.
- The next Q lines each contain two integers A and B — the endpoints of a query (1 ≤ A ≤ B ≤ N).

Output Format
- Print Q lines.
- For each query [A, B], output: max(H[A..B]) − min(H[A..B]).

Constraints
- 1 ≤ N ≤ 50,000
- 1 ≤ Q ≤ 180,000
- 1 ≤ H_i ≤ 1,000,000
- 1 ≤ A ≤ B ≤ N
- Indices are 1-based.

Sample Input
6 3
1
7
3
4
2
5
1 5
4 6
2 2

Sample Output
6
3
0

Notes / Tips
- This is a static range query problem. A common approach is to build two Sparse Tables (one for maximums, one for minimums) in O(N log N), then answer each query in O(1) as:
    answer = max_query(A, B) − min_query(A, B).
- Alternatively, a segment tree can answer each query in O(log N).
- Because Q is large, prefer fast I/O in C++ (e.g., ios::sync_with_stdio(false); cin.tie(nullptr);).

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
