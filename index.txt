Title: Static Range Maximum Query (Sparse Table Classic)

Title Background
This is a classic ST (Sparse Table) problem — Static interval maximum.

Please note that the maximum time limit is only 0.8s and the data strength is not low. You must ensure your per-query complexity is O(1). Using a higher time complexity algorithm may not pass.

If you believe your algorithm has the right complexity but you still get TLE, try using fast input. For example, in C++:

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
    return x * f;
}

(The function returns the first integer read in. Fast I/O is optional; it only helps speed up input.)

Problem Description
You are given a sequence of length N and M queries. For each query, find the maximum value in the specified interval.

Input Format
- The first line contains two integers N and M — the length of the sequence and the number of queries.
- The second line contains N integers A_i, representing the elements of the sequence.
- Each of the next M lines contains two integers L_i and R_i, indicating a query interval [L_i, R_i] (1-indexed, inclusive).

Output Format
Output M lines, one integer per line, where each line is the maximum value in the corresponding query interval.

Sample Input
8 8
9 3 1 7 5 6 0 8
1 6
1 5
2 7
2 6
1 8
4 8
3 7
1 8

Sample Output
9
9
7
7
9
8
7
9

Constraints
- 1 ≤ N ≤ 10^5
- 1 ≤ M ≤ 2 × 10^6
- 0 ≤ A_i ≤ 10^9
- 1 ≤ L_i ≤ R_i ≤ N

Notes / Tips
- This is a static RMQ (Range Maximum Query) with no updates. Preprocess in O(N log N) using a Sparse Table, answer each query in O(1).
- Due to large M and tight time limit, consider fast I/O (e.g., scanf/printf, ios::sync_with_stdio(false), or the provided read() function in C++).

xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Title: Balanced Lineup (USACO 2007 JAN) — Range Max–Min Query

Problem Description
Farmer John’s N cows (1 ≤ N ≤ 5×10^4) stand in a fixed order. He considers Q (1 ≤ Q ≤ 1.8×10^5) possible contiguous groups of cows. For each query range [A, B] (1-indexed, inclusive), report the difference between the tallest and the shortest cow within that range.

Input Format
- The first line contains two integers N and Q.
- The next N lines each contain an integer H_i — the height of the i-th cow.
- The next Q lines each contain two integers A and B — the endpoints of a query (1 ≤ A ≤ B ≤ N).

Output Format
- Print Q lines.
- For each query [A, B], output: max(H[A..B]) − min(H[A..B]).

Constraints
- 1 ≤ N ≤ 50,000
- 1 ≤ Q ≤ 180,000
- 1 ≤ H_i ≤ 1,000,000
- 1 ≤ A ≤ B ≤ N
- Indices are 1-based.

Sample Input
6 3
1
7
3
4
2
5
1 5
4 6
2 2

Sample Output
6
3
0

Notes / Tips
- This is a static range query problem. A common approach is to build two Sparse Tables (one for maximums, one for minimums) in O(N log N), then answer each query in O(1) as:
    answer = max_query(A, B) − min_query(A, B).
- Alternatively, a segment tree can answer each query in O(log N).
- Because Q is large, prefer fast I/O in C++ (e.g., ios::sync_with_stdio(false); cin.tie(nullptr);).

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Title: P3097 [USACO13DEC] Optimal Milking G

Problem Description
Farmer John has N milking machines arranged in a line, numbered 1..N (1 ≤ N ≤ 40000). 
Machine i can produce Mi units of milk in a day. However, machines are installed too closely:
if a machine i is used on a given day, its adjacent machines (i−1 and i+1) cannot be used that day.

There are D days (1 ≤ D ≤ 50000). At the start of each day, exactly one maintenance update occurs:
Mi is set to a new value m. After applying that day’s update, Farmer John will choose a set of
machines to use such that no two chosen indices are adjacent, maximizing the total milk for that day.

Your task is to compute the sum of these daily maxima over all D days and output this total.
(Note: 32-bit integers may overflow; use 64-bit.)

Input Format
- Line 1: Two integers N, D.
- Lines 2..N+1: Line i+1 contains a single integer Mi (initial production of machine i).
- Lines N+2..N+1+D: Each line has two integers i, m — at the start of that day, set Mi ← m.

Output Format
- Print a single integer: the sum, over all D days, of the maximum obtainable milk after that day’s update.

Constraints
- 1 ≤ N ≤ 40,000
- 1 ≤ D ≤ 50,000
- Mi and m are positive integers (use 64-bit when summing)
- No two used machines in a day may be adjacent

Sample Input
5 3
1
2
3
4
5
5 2
2 7
1 10

Sample Output
32

Explanation (for the sample)
Day 1 after update: M = [1,2,3,4,2] → best is 2+4=6 (or 1+3+2=6).
Day 2 after update: M = [1,7,3,4,2] → best is 7+4=11.
Day 3 after update: M = [10,7,3,4,2] → best is 10+3+2=15.
Total = 6 + 11 + 15 = 32.

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


ANDROUND - AND Rounds
#tree

You are given a cyclic array A having N numbers. In an AND round, each element of the array A is replaced by the bitwise AND of itself, the previous element, and the next element in the array. All operations take place simultaneously. Can you calculate A after K such AND rounds?

Input
The first line contains the number of test cases T (T ≤ 50).
There follow 2T lines, 2 per test case. The first line contains two space separated integers N (3 ≤ N ≤ 20000) and K (1 ≤ K ≤ 1000000000). The next line contains N space separated integers Ai (0 ≤ Ai ≤ 1000000000), which are the initial values of the elements in array A.

Output
Output T lines, one per test case. For each test case, output a space separated list of N integers, specifying the contents of array A after K AND rounds.

Example
Input:
2 
3 1 
1 2 3 
5 100 
1 11 111 1111 11111 

Output:
0 0 0 
1 1 1 1 1
